from djitellopy import Tello
from ultralytics import YOLO
import cv2
import time
import numpy as np

TARGET_CLASS_ID = 32  # COCO: sports ball


def get_main_ball_box(result):
    """
    YOLO ê²°ê³¼ì—ì„œ sports ball(class 32)ë“¤ ì¤‘ 'ê°€ì¥ í° ê³µ' 1ê°œì˜
    ë°•ìŠ¤(x1,y1,x2,y2)ì™€ confë¥¼ ë°˜í™˜. ì—†ìœ¼ë©´ (None, None)
    """
    boxes = result.boxes
    if boxes is None or len(boxes) == 0:
        return None, None

    xyxy = boxes.xyxy.cpu().numpy()      # [N, 4]
    classes = boxes.cls.cpu().numpy()
    confs = boxes.conf.cpu().numpy() if boxes.conf is not None else None

    best_box = None
    best_conf = None
    best_area = 0

    for i, (box, cls_id) in enumerate(zip(xyxy, classes)):
        if int(cls_id) != TARGET_CLASS_ID:
            continue

        x1, y1, x2, y2 = box
        area = (x2 - x1) * (y2 - y1)
        if area > best_area:
            best_area = area
            best_box = box
            best_conf = float(confs[i]) if confs is not None else None

    return best_box, best_conf


class Kalman1D_RatioCV:
    """
    1D ì¹¼ë§Œí•„í„° (Constant Velocity)
    ìƒíƒœ x = [ratio, ratio_velocity]^T
    ì¸¡ì • z = ratio
    """

    def __init__(self, dt, q_ratio=0.02, q_vel=0.10, r_meas=0.08,
                 p0_ratio=0.30, p0_vel=1.00):
        self.dt = dt

        # ìƒíƒœ [ratio, vel]
        self.x = np.array([[0.0],
                           [0.0]], dtype=np.float32)

        # ê³µë¶„ì‚° P
        self.P = np.array([[p0_ratio, 0.0],
                           [0.0,      p0_vel]], dtype=np.float32)

        # ìƒíƒœ ì „ì´ F
        self.F = np.array([[1.0, dt],
                           [0.0, 1.0]], dtype=np.float32)

        # ê´€ì¸¡ í–‰ë ¬ H (ratioë§Œ ì¸¡ì •)
        self.H = np.array([[1.0, 0.0]], dtype=np.float32)

        # í”„ë¡œì„¸ìŠ¤ ë…¸ì´ì¦ˆ Q (ëª¨ë¸ì´ ì–¼ë§ˆë‚˜ í‹€ë¦´ ìˆ˜ ìˆë‚˜)
        self.Q = np.array([[q_ratio, 0.0],
                           [0.0,     q_vel]], dtype=np.float32)

        # ì¸¡ì • ë…¸ì´ì¦ˆ R (YOLO ratio í”ë“¤ë¦¼)
        self.R = np.array([[r_meas]], dtype=np.float32)

        self.I = np.eye(2, dtype=np.float32)

        self.initialized = False

    def reset(self, ratio, vel=0.0):
        self.x[:] = np.array([[float(ratio)],
                              [float(vel)]], dtype=np.float32)
        self.initialized = True

    def predict(self):
        # x = F x
        self.x = self.F @ self.x
        # P = F P F^T + Q
        self.P = self.F @ self.P @ self.F.T + self.Q

        return float(self.x[0, 0])  # predicted ratio

    def update(self, z):
        z = float(z)
        Z = np.array([[z]], dtype=np.float32)

        # innovation y = z - Hx
        y = Z - (self.H @ self.x)

        # S = HPH^T + R
        S = self.H @ self.P @ self.H.T + self.R

        # K = P H^T S^-1
        K = self.P @ self.H.T @ np.linalg.inv(S)

        # x = x + K y
        self.x = self.x + K @ y

        # P = (I - K H) P
        self.P = (self.I - K @ self.H) @ self.P

        return float(self.x[0, 0])  # updated ratio

    def innovation_abs(self, z):
        """í˜„ì¬ ì˜ˆì¸¡ê°’ê³¼ ì¸¡ì •ê°’ ì°¨ì´(|z - Hx|)"""
        return abs(float(z) - float((self.H @ self.x)[0, 0]))


def main():
    YOLO_W, YOLO_H = 320, 240

    # YOLO í•„í„°ë§(ì¶”ì²œ)
    YOLO_CONF_THRES = 0.20       # ë‚®ì¶”ë©´ ë” ì˜ ì¡ì§€ë§Œ ì˜¤íƒâ†‘
    YOLO_IOU_THRES = 0.45

    # ì—…ë°ì´íŠ¸í• ì§€ ê²Œì´íŒ…
    MIN_UPDATE_CONF = 0.25       # ì´ conf ì•„ë˜ë©´ ì¹¼ë§Œ ì—…ë°ì´íŠ¸ ì•ˆ í•¨
    MAX_INNOVATION = 0.55        # ì˜ˆì¸¡ ratioì™€ ê´€ì¸¡ ratio ì°¨ì´ê°€ ì´ë³´ë‹¤ í¬ë©´ ì´ìƒì¹˜ë¡œ ë³´ê³  ì—…ë°ì´íŠ¸ ì•ˆ í•¨

    # ê°€ë ¤ì§ ë•Œë„ ì˜ˆì¸¡ìœ¼ë¡œ yawë¥¼ ê³„ì† í• ì
    HOLD_FRAMES_WHEN_MISSING = 10  # íƒì§€ ëŠê²¨ë„ ì˜ˆì¸¡ìœ¼ë¡œ ë²„í‹¸ í”„ë ˆì„ ìˆ˜
    YAW_WHEN_MISSING_SCALE = 0.65  # íƒì§€ ì—†ìŒ êµ¬ê°„ì—ì„œ yawë¥¼ ì–¼ë§ˆë‚˜ ì•½í•˜ê²Œ í• ì§€ (0~1)

    # ì¤‘ì•™ í—ˆìš© ì˜¤ì°¨
    center_tolerance_ratio = 0.06

    # yaw ë¹„ë¡€ì œì–´
    Kp = 60
    MAX_YAW = 80

    # ì¹¼ë§Œí•„í„° íŒŒë¼ë¯¸í„°(ì¶”ì²œ ì‹œì‘ì )
    # - R(ì¸¡ì • ë…¸ì´ì¦ˆ) â†‘ : YOLO ëœ ë¯¿ê³  ë” ë¶€ë“œëŸ¬ì›€ / ë°˜ì‘ ëŠë¦¼
    # - Q(í”„ë¡œì„¸ìŠ¤ ë…¸ì´ì¦ˆ) â†‘ : ê¸‰ê²©í•œ ì›€ì§ì„ ë” ì˜ ë”°ë¼ê° / í”ë“¤ë¦¼â†‘
    KF_DT = 1.0 / 30.0      # ëŒ€ì¶© 30fps ê°€ì •. ì‹¤ì œ fpsì— ë§ì¶”ë©´ ë” ì¢‹ìŒ.
    KF_Q_RATIO = 0.02
    KF_Q_VEL = 0.10
    KF_R_MEAS = 0.08
    KF_P0_RATIO = 0.30
    KF_P0_VEL = 1.00


    model = YOLO("best.pt")

    tello = Tello()
    tello.connect()
    print("ë°°í„°ë¦¬:", tello.get_battery())

    tello.streamon()
    frame_read = tello.get_frame_read()

    tello.takeoff()
    time.sleep(1)

    # ì¹¼ë§Œí•„í„° ìƒì„±
    kf = Kalman1D_RatioCV(
        dt=KF_DT,
        q_ratio=KF_Q_RATIO,
        q_vel=KF_Q_VEL,
        r_meas=KF_R_MEAS,
        p0_ratio=KF_P0_RATIO,
        p0_vel=KF_P0_VEL
    )

    missing_count = 0  # íƒì§€ ëŠê¸´ í”„ë ˆì„ ìˆ˜

    try:
        while True:
            frame = frame_read.frame
            if frame is None:
                continue

            # Tello frame -> OpenCV BGR
            frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)

            h, w = frame.shape[:2]
            frame_center_x = w / 2
            annotated_frame = frame.copy()

            small = cv2.resize(frame, (YOLO_W, YOLO_H))

            # 1) ì¹¼ë§Œ ì˜ˆì¸¡ì€ ë§¤ í”„ë ˆì„ ìˆ˜í–‰
            pred_ratio = kf.predict() if kf.initialized else None

            ball_box_full = None
            ball_conf = None
            meas_ratio = None
            updated_this_frame = False

            # 2) YOLO ì¸¡ì •(ìˆìœ¼ë©´ update)
            try:
                results = model.predict(
                    source=small,
                    conf=YOLO_CONF_THRES,
                    iou=YOLO_IOU_THRES,
                    classes=[TARGET_CLASS_ID],
                    verbose=False
                )
                result = results[0]

                ball_box_small, ball_conf = get_main_ball_box(result)

                if ball_box_small is not None:
                    x1, y1, x2, y2 = ball_box_small

                    # small -> full ìŠ¤ì¼€ì¼ ë³€í™˜(ê·¸ë¦¬ê¸° ìš©)
                    sx = w / YOLO_W
                    sy = h / YOLO_H
                    fx1, fy1, fx2, fy2 = int(x1 * sx), int(y1 * sy), int(x2 * sx), int(y2 * sy)
                    ball_box_full = (fx1, fy1, fx2, fy2)

                    # ì¸¡ì • ratio (-1~1)
                    ball_center_x_small = (x1 + x2) / 2
                    meas_ratio = (ball_center_x_small - YOLO_W / 2) / (YOLO_W / 2)

                    # ì´ˆê¸°í™”(ì²« íƒì§€)
                    if not kf.initialized:
                        kf.reset(meas_ratio, vel=0.0)
                        pred_ratio = meas_ratio

                    # ê²Œì´íŒ…: conf ë‚®ê±°ë‚˜, ì˜ˆì¸¡ê³¼ ë„ˆë¬´ ë‹¤ë¥´ë©´ update skip
                    do_update = True
                    if ball_conf is not None and ball_conf < MIN_UPDATE_CONF:
                        do_update = False

                    if kf.initialized and meas_ratio is not None:
                        if kf.innovation_abs(meas_ratio) > MAX_INNOVATION:
                            do_update = False

                    if do_update and meas_ratio is not None:
                        fused_ratio = kf.update(meas_ratio)
                        pred_ratio = fused_ratio
                        updated_this_frame = True
                        missing_count = 0
                    else:
                        # ì¸¡ì •ì€ ìˆì§€ë§Œ update ì•ˆ í•¨ -> ì˜ˆì¸¡ë§Œ ì‚¬ìš©
                        missing_count += 1

                else:
                    # íƒì§€ ìì²´ê°€ ì—†ìŒ
                    missing_count += 1

            except Exception as e:
                print("YOLO ì¶”ë¡  ì¤‘ ì˜¤ë¥˜:", e)
                missing_count += 1

            # 3) yaw ê²°ì •: ì¹¼ë§Œ ì¶”ì •(pred_ratio)ì„ ì‚¬ìš©
            yaw_speed = 0
            use_ratio = None

            if kf.initialized and pred_ratio is not None:
                if missing_count <= HOLD_FRAMES_WHEN_MISSING:
                    use_ratio = pred_ratio
                else:
                    use_ratio = None  # ë„ˆë¬´ ì˜¤ë˜ ëª» ì°¾ìœ¼ë©´ í¬ê¸°(ì•ˆì „)

            if use_ratio is not None:
                # í™”ë©´ ì¤‘ì•™ì„ 
                cv2.line(annotated_frame, (int(frame_center_x), 0),
                         (int(frame_center_x), h), (0, 255, 0), 1)

                # ë¹¨ê°„ ì  (ì˜ˆì¸¡ ê³µ x ìœ„ì¹˜)
                px = int((use_ratio * (w / 2)) + frame_center_x)
                cv2.circle(annotated_frame, (px, h // 2), 8, (0, 0, 255), -1)

                # ê³µ ë°•ìŠ¤ (íƒì§€ëœ í”„ë ˆì„ì¼ ë•Œë§Œ ì‹¤ì œ ë°•ìŠ¤ í‘œì‹œ)
                if ball_box_full is not None:
                    x1, y1, x2, y2 = ball_box_full
                    cv2.rectangle(annotated_frame, (x1, y1), (x2, y2), (0, 255, 255), 2)
                    label = "sports_ball"
                    if ball_conf is not None:
                        label += f" {ball_conf:.2f}"
                    cv2.putText(annotated_frame, label, (x1, max(0, y1 - 8)),
                                cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 255), 2)

                # yaw ì œì–´
                if abs(use_ratio) > center_tolerance_ratio:
                    yaw_speed = int(use_ratio * Kp)
                    yaw_speed = int(np.clip(yaw_speed, -MAX_YAW, MAX_YAW))

                    # íƒì§€ ì—†ìŒ(ì˜ˆì¸¡ë§Œ) êµ¬ê°„ì—ì„œëŠ” yawë¥¼ ì•½í•˜ê²Œ
                    if not updated_this_frame:
                        yaw_speed = int(yaw_speed * YAW_WHEN_MISSING_SCALE)

                    cv2.putText(annotated_frame,
                                f"KF TRACK yaw={yaw_speed} miss={missing_count}",
                                (10, 40),
                                cv2.FONT_HERSHEY_SIMPLEX, 1.0, (0, 255, 255), 2)
                else:
                    cv2.putText(annotated_frame, "BALL CENTERED", (10, 40),
                                cv2.FONT_HERSHEY_SIMPLEX, 1.0, (0, 255, 0), 2)

                # ë””ë²„ê·¸: ì¸¡ì • vs ì˜ˆì¸¡
                if meas_ratio is not None:
                    cv2.putText(annotated_frame,
                                f"meas={meas_ratio:+.2f} pred={pred_ratio:+.2f} conf={ball_conf if ball_conf else 0:.2f}",
                                (10, 75),
                                cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)
                else:
                    cv2.putText(annotated_frame,
                                f"meas=None pred={pred_ratio:+.2f}",
                                (10, 75),
                                cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)

            else:
                cv2.putText(annotated_frame, "NO BALL (KF LOST)", (10, 40),
                            cv2.FONT_HERSHEY_SIMPLEX, 1.0, (0, 0, 255), 2)
                yaw_speed = 0

            # 4) RC ì œì–´
            try:
                tello.send_rc_control(0, 0, 0, yaw_speed)
            except Exception as e:
                print("send_rc_control ì˜¤ë¥˜:", e)

            cv2.imshow("Tello + YOLO Sports Ball Tracking (KF)", annotated_frame)

            key = cv2.waitKey(1) & 0xFF
            if key == ord('q'):
                print("ğŸ§¨ q ì…ë ¥, ì •ì§€ ë° ì°©ë¥™")
                tello.send_rc_control(0, 0, 0, 0)
                tello.land()
                break

    finally:
        try:
            tello.send_rc_control(0, 0, 0, 0)
        except Exception:
            pass
        tello.streamoff()
        tello.end()
        cv2.destroyAllWindows()


if __name__ == "__main__":
    main()


'''
YOLO_CONF_THRES (ì¶”ì²œ 0.20)
â†“ ë” ì˜ ì¡ìŒ(ê°€ë ¤ì§/ì‘ì€ ê³µ) ëŒ€ì‹  ì˜¤íƒâ†‘
â†‘ ì˜¤íƒâ†“ ëŒ€ì‹  ë†“ì¹¨â†‘

YOLO_IOU_THRES (ì¶”ì²œ 0.45)
ë³´í†µì€ ê±´ë“œë¦´ ì¼ ì ìŒ

2) â€œì—…ë°ì´íŠ¸(ê´€ì¸¡ ë°˜ì˜) ê²Œì´íŒ…â€

MIN_UPDATE_CONF (ì¶”ì²œ 0.25)
ì˜¤íƒì´ ì¹¼ë§Œì„ ë§ì¹˜ëŠ” ê±¸ ë§‰ëŠ” 1ì°¨ ë°©ì–´ì„ 

MAX_INNOVATION (ì¶”ì²œ 0.55)
ê°‘ìê¸° í™”ë©´ ë°˜ëŒ€í¸ìœ¼ë¡œ íŠ€ëŠ” ì¸¡ì •ê°’(ëŒ€ë¶€ë¶„ ì˜¤íƒ) ë°°ì œ
ê°’ ë„ˆë¬´ ì‘ìœ¼ë©´ â€œì§„ì§œ ê³µâ€ë„ ì—…ë°ì´íŠ¸ ì•ˆ ë  ìˆ˜ ìˆìŒ

3) ê°€ë ¤ì§ ë²„í‹°ê¸°(ì¶”ì  ìœ ì§€)

HOLD_FRAMES_WHEN_MISSING (ì¶”ì²œ 10)
íƒì§€ ëŠê²¨ë„ ì˜ˆì¸¡ìœ¼ë¡œ yawë¥¼ ê³„ì†í•˜ëŠ” ìµœëŒ€ í”„ë ˆì„ ìˆ˜
ë„ˆë¬´ í¬ë©´ â€œì—‰ëš±í•œ ë°©í–¥â€ìœ¼ë¡œ ê³„ì† ëŒ ìœ„í—˜

YAW_WHEN_MISSING_SCALE (ì¶”ì²œ 0.65)
íƒì§€ ì—†ëŠ” êµ¬ê°„ì—ì„œ yawë¥¼ ì•½í•˜ê²Œ í•´ì„œ í­ì£¼ ë°©ì§€

4) ì¹¼ë§Œí•„í„° ëŠë‚Œì„ ë°”ê¾¸ëŠ” í•µì‹¬ 2ê°œ

KF_R_MEAS (ì¶”ì²œ 0.08) â† YOLOë¥¼ ì–¼ë§ˆë‚˜ ë¯¿ì„ì§€
â†‘ ë” ë¶€ë“œëŸ¬ì›€ / ë°˜ì‘ ëŠë¦¼
â†“ ë” ë¯¼ê° / í”ë“¤ë¦¼ ì¦ê°€

KF_Q_VEL (ì¶”ì²œ 0.10) â† ê¸‰ë³€ì„ ì–¼ë§ˆë‚˜ í—ˆìš©í• ì§€
â†‘ ê¸‰ê²©í•œ ì›€ì§ì„ë„ ë”°ë¼ê°
â†“ ë” ë§¤ëˆí•˜ì§€ë§Œ ê°€ë ¤ì§ í›„ ë³µê·€ê°€ ëŠë¦´ ìˆ˜ ìˆìŒ
'''
